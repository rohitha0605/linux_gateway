/// Protocol frame version we emit/accept.
pub const PROTO_VERSION: u8 = 1;

/// Compute CRC32 of a payload.
pub fn crc32(payload: &[u8]) -> u32 {
    let mut h = crc32fast::Hasher::new();
    h.update(payload);
    h.finalize()
}

/// Wrap a payload as a v1 frame:
///   [0]       : u8   version = 1
///   [1..N-5]  : bytes payload
///   [N-4..N]  : u32  crc32(payload) LE
pub fn wrap_v1(payload: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(1 + payload.len() + 4);
    out.push(PROTO_VERSION);
    out.extend_from_slice(payload);
    out.extend_from_slice(&crc32(payload).to_le_bytes());
    out
}

/// Validate and return the inner payload from a v1 frame.
///
/// Errors are stringly-typed so callers can map to their own error enums.
pub fn unwrap_v1(frame: &[u8]) -> Result<&[u8], &'static str> {
    if frame.len() < 1 + 4 {
        return Err("frame too short");
    }
    if frame[0] != PROTO_VERSION {
        return Err("wrong version");
    }
    let payload_len = frame.len() - 1 - 4;
    let (payload, crc_bytes) = frame[1..].split_at(payload_len);
    let got = u32::from_le_bytes([crc_bytes[0], crc_bytes[1], crc_bytes[2], crc_bytes[3]]);
    let want = crc32(payload);
    if got != want { return Err("crc mismatch"); }
    Ok(payload)
}
