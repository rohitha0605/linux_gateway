
use tracing_opentelemetry::OpenTelemetrySpanExt;
use std::{env, process};

mod telemetry;

const HELP: &str = "Usage:
  linux_gateway --decode HEX
  linux_gateway make-resp <SUM>
  linux_gateway make-req-trace <A> <B>
  linux_gateway rpmsg-bounce <HEX>
  linux_gateway --version
";

fn parse_hex(s: &str) -> Result<Vec<u8>, ()> {
    if s.len() % 2 != 0 {
        return Err(());
    }
    let mut out = Vec::with_capacity(s.len() / 2);
    let bytes = s.as_bytes();
    let mut i = 0;
    while i < s.len() {
        let hi = (bytes[i] as char).to_digit(16).ok_or(())?;
        let lo = (bytes[i + 1] as char).to_digit(16).ok_or(())?;
        out.push(((hi << 4) | lo) as u8);
        i += 2;
    }
    Ok(out)
}

#[tokio::main]
async fn main() {
    let _ = telemetry::init("linux_gateway");

    // root span for CLI
    let cli_span = tracing::info_span!("cli");
    
    let _cli_enter = cli_span.enter();
    let argv: Vec<String> = env::args().collect();

    // rpmsg-bounce <HEX>  -> decode request, echo trace parent, compute, encode response
    if argv.len() == 3 && argv[1] == "rpmsg-bounce" {
        let hex_arg = &argv[2];
        let data = match hex::decode(hex_arg) {
            Ok(d) => d,
            Err(e) => { eprintln!("HEX_DECODE_ERR={e}"); process::exit(2) }
        };

        match linux_gateway::decode_calc_request(&data) {
    Ok(req) => {
                let r5_span = tracing::info_span!("r5_compute", a = req.a, b = req.b);
                if let Some(cx) = linux_gateway::otel_trace::from_proto(req.trace.as_ref()) {
                    r5_span.set_parent(cx);
                }
                let _r5_enter = r5_span.enter();
use tracing_opentelemetry::OpenTelemetrySpanExt;
        if let Some(cx) = linux_gateway::otel_trace::from_proto(req.trace.as_ref()) {
        }
        let _r5_enter = r5_span.enter();

                {
                    use tracing_opentelemetry::OpenTelemetrySpanExt as _;
                    if let Some(cx) = linux_gateway::otel_trace::from_proto(req.trace.as_ref()) {
                    }
                }
                let _r5_enter = r5_span.enter();
                // Child span on R5, parented to incoming header
                {
                    use tracing_opentelemetry::OpenTelemetrySpanExt as _;
                    if let Some(cx) = linux_gateway::otel_trace::from_proto(req.trace.as_ref()) {
                    }
                }
                let _r5_enter = r5_span.enter();
                                if let Some(cx) = linux_gateway::otel_trace::from_proto(req.trace.as_ref()) {
                }
if let Some(cx) = linux_gateway::otel_trace::from_proto(req.trace.as_ref()) {
                }
                let _r5_enter = r5_span.enter();
                let t0 = std::time::Instant::now();
                let sum = (req.a as i64 + req.b as i64) as i32;
let tid_hex = req.trace.as_ref().map(|t| hex::encode_upper(&t.trace_id));
                tracing::info!(
                    elapsed_ms = t0.elapsed().as_millis() as u64,
                    result = sum,
                    trace_id = tid_hex.as_deref().unwrap_or(""),
                    "r5_compute_done"
                );

                let resp = linux_gateway::proto::CalcResponse { result: sum, trace: req.trace.clone(), };
                let resp = linux_gateway::proto::CalcResponse { result: sum as i32, trace: req.trace.clone() };
                
                let resp = linux_gateway::proto::CalcResponse { result: sum as i32, trace: req.trace.clone() };
                let frame = linux_gateway::encode_calc_response(&resp);


                println!("{}", hex::encode_upper(frame));
            }
            Err(e) => { eprintln!("DECODE_REQ_ERR={e}"); process::exit(1) }
        }
        return;
    }

    if argv.len() == 1 || argv[1] == "-h" || argv[1] == "--help" {
        println!("{HELP}");
        return;
    }

    if argv[1] == "--version" || argv[1] == "-V" {
        println!("{}", env!("CARGO_PKG_VERSION"));
        return;
    }

    match argv[1].as_str() {
        s if s.starts_with("--decode") => {
            let val = if let Some(eq) = s.strip_prefix("--decode=") {
                eq.to_string()
            } else if s == "--decode" && argv.len() >= 3 {
                argv[2].clone()
            } else {
                eprintln!("{HELP}");
                process::exit(2);
            };
            if parse_hex(&val).is_err() {
                eprintln!("decode: invalid hex");
                process::exit(2);
            }
        }
        "make-resp" | "make_resp" => {
            if argv.len() < 3 {
                eprintln!("{HELP}");
                process::exit(2);
            }
            let sum: u32 = match argv[2].parse() {
                Ok(v) => v,
                Err(_) => { eprintln!("make-resp: invalid number"); process::exit(2); }
            };
            let resp = linux_gateway::proto::CalcResponse { result: sum as i32, trace: None };
            let frame = linux_gateway::encode_calc_response(&resp);
            println!("{}", hex::encode_upper(frame));
        }
         "make-req-trace" | "make_req_trace" => {
            let req_span = tracing::info_span!("linux_request");
            let _enter_req = req_span.enter();
let make_span = tracing::info_span!("linux_request");
            let _enter = make_span.enter();

            if argv.len() < 4 {
                eprintln!("{HELP}");
                process::exit(2);
            }
            let a: i32 = argv[2].parse().unwrap_or_else(|_| { eprintln!("invalid A"); process::exit(2); });
            let b: i32 = argv[3].parse().unwrap_or_else(|_| { eprintln!("invalid B"); process::exit(2); });

            // include current trace context in the request frame
            let frame = linux_gateway::encode_calc_request(a, b, linux_gateway::otel_trace::current());
            println!("{}", hex::encode_upper(frame));
        }
        _ => {
            println!("{HELP}");
            process::exit(2);
        }
    }
}
