use crc32fast::Hasher;
use prost::Message;

#[derive(Debug)]
pub enum FrameError {
    Decode,
    UnknownVersion(u8),
    TooShort,
    /// Kept for test-compat: tests match on `FrameError::Crc`
    Crc,
    /// Optional rich error if you want to use it elsewhere
    BadCrc { got: u32, want: u32 },
}

impl std::fmt::Display for FrameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            FrameError::Decode => write!(f, "decode failed"),
            FrameError::UnknownVersion(v) => write!(f, "unknown version {v:#04x}"),
            FrameError::TooShort => write!(f, "frame too short"),
            FrameError::Crc => write!(f, "crc mismatch"),
            FrameError::BadCrc { got, want } => {
                write!(f, "crc mismatch got={got:#010x} want={want:#010x}")
            }
        }
    }
}
impl std::error::Error for FrameError {}

fn crc32(data: &[u8]) -> u32 {
    let mut h = Hasher::new();
    h.update(data);
    h.finalize()
}

// Generated by prost in build.rs
pub mod proto {
    pub mod rpmsg {
        pub mod calc {
            pub mod v1 {
                include!(concat!(env!("OUT_DIR"), "/rpmsg.calc.v1.rs"));
            }
        }
    }
}

/// Public wire helpers (tests import `linux_gateway::wire`)
pub mod wire {
    use super::{crc32, FrameError};

    pub const VER: u8 = 1;
    /// Kept for test/bin compat
    pub const PROTO_VERSION: u8 = VER;

    /// v1 frame = [version=1][payload...][crc32(payload) little-endian]
    pub fn wrap_v1(payload: &[u8]) -> Vec<u8> {
        let mut out = Vec::with_capacity(1 + payload.len() + 4);
        out.push(VER);
        out.extend_from_slice(payload);
        let c = crc32(payload);
        out.extend_from_slice(&c.to_le_bytes());
        out
    }

    /// Return the payload slice if the frame is well-formed.
    pub fn unwrap_v1(frame: &[u8]) -> Result<&[u8], FrameError> {
        // Need at least version + crc32
        if frame.len() < 1 + 4 {
            return Err(FrameError::TooShort);
        }
        let ver = frame[0];
        if ver != VER {
            return Err(FrameError::UnknownVersion(ver));
        }

        // Split [payload][crc32-le]
        let payload_len = frame.len() - 1 - 4;
        let (payload, crc_bytes) = frame[1..].split_at(payload_len);
        let got = u32::from_le_bytes([crc_bytes[0], crc_bytes[1], crc_bytes[2], crc_bytes[3]]);
        let want = crc32(payload);
        if got != want {
            // tests expect this exact variant:
            return Err(FrameError::Crc);
            // If you prefer the richer error, use:
            // return Err(FrameError::BadCrc { got, want });
        }
        Ok(payload)
    }
}

// ==== calc v1 encoders/decoders ====

/// Canonical framed request: version(1) + protobuf payload + CRC32(payload)
pub fn encode_calc_request(a: u32, b: u32) -> Vec<u8> {
    let req = proto::rpmsg::calc::v1::CalcRequest {
        a,
        b,
        op: proto::rpmsg::calc::v1::calc_request::Op::Sum as i32,
    };
    let mut payload = Vec::new();
    req.encode(&mut payload).expect("encode");
    wire::wrap_v1(&payload)
}

/// Canonical framed response: version(1) + protobuf payload + CRC32(payload)
pub fn encode_calc_response(sum: u32) -> Vec<u8> {
    let resp = proto::rpmsg::calc::v1::CalcResponse { result: sum };
    let mut payload = Vec::new();
    resp.encode(&mut payload).expect("encode");
    wire::wrap_v1(&payload)
}

/// Same frame, plus synthetic trace id and timestamp (ns since epoch)
pub fn encode_calc_request_with_trace(a: u32, b: u32) -> (Vec<u8>, Vec<u8>, u64) {
    let frame = encode_calc_request(a, b);
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("time");
    let ts_ns: u64 = now.as_nanos() as u64;
    let trace_id = ts_ns.to_le_bytes().to_vec();
    (frame, trace_id, ts_ns)
}

pub fn decode_calc_request(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcRequest, FrameError> {
    let payload = wire::unwrap_v1(frame)?;
    proto::rpmsg::calc::v1::CalcRequest::decode(payload).map_err(|_| FrameError::Decode)
}

pub fn decode_calc_response(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcResponse, FrameError> {
    let payload = wire::unwrap_v1(frame)?;
    proto::rpmsg::calc::v1::CalcResponse::decode(payload).map_err(|_| FrameError::Decode)
}
