pub mod wire;
use crc32fast::Hasher;
use prost::Message;
use thiserror::Error;

// --- framing constants ---
const SYNC: u16 = 0xA55A;
const VER: u8 = 0x01;

#[repr(u8)]
enum MsgType {
    CalcReq = 1,
    CalcResp = 2,
}

fn crc32(data: &[u8]) -> u32 {
    let mut h = Hasher::new();
    h.update(data);
    h.finalize()
}

// Generated by prost in build.rs
pub mod proto {
    pub mod rpmsg {
        pub mod calc {
            pub mod v1 {
                include!(concat!(env!("OUT_DIR"), "/rpmsg.calc.v1.rs"));
            }
        }
    }
}

#[derive(Debug, Error)]
pub enum FrameError {
    #[error("decode failed")]
    Decode,

    #[error("unknown version {0:#04x}")]
    UnknownVersion(u8),
    #[error("unknown type {0:#04x}")]
    UnknownType(u8),

    #[error("short header")]
    ShortHeader,
    #[error("bad sync")]
    BadSync,
    #[error("length mismatch")]
    Length,
    #[error("crc mismatch")]
    Crc,
    #[error("{0}")]
    ProstDecode(#[from] prost::DecodeError),
}

pub fn decode_calc_response(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcResponse, FrameError> {
    // backport-guards: response
    if frame.len() >= 4 {
        let ver = frame[2];
        if ver != 1 {
            return Err(FrameError::UnknownVersion(ver));
        }
        let typ = frame[3];
        if typ != 1 && typ != 2 {
            return Err(FrameError::UnknownType(typ));
        }
    }

    if frame.len() < 10 {
        return Err(FrameError::ShortHeader);
    }
    if u16::from_be_bytes([frame[0], frame[1]]) != SYNC {
        return Err(FrameError::BadSync);
    }

    let _ver = frame[2];
    let typ = frame[3];
    let len = u16::from_be_bytes([frame[4], frame[5]]) as usize;
    let got_crc = u32::from_be_bytes([frame[6], frame[7], frame[8], frame[9]]);

    let need = 10 + len;
    if frame.len() < need {
        return Err(FrameError::Length);
    }

    let payload = &frame[10..need];
    if crc32(payload) != got_crc {
        return Err(FrameError::Crc);
    }
    if typ != MsgType::CalcResp as u8 {
        return Err(FrameError::Length);
    }

    proto::rpmsg::calc::v1::CalcResponse::decode(payload).map_err(|_| FrameError::Decode)
}

pub fn encode_calc_response(sum: u32) -> Vec<u8> {
    let resp = proto::rpmsg::calc::v1::CalcResponse { result: sum };
    let mut payload = Vec::with_capacity(8);
    resp.encode(&mut payload).expect("encode");

    let crc = crc32(&payload);
    let mut frame = Vec::with_capacity(10 + payload.len());
    frame.extend_from_slice(&SYNC.to_be_bytes());
    frame.push(VER);
    frame.push(MsgType::CalcResp as u8);
    frame.extend_from_slice(&(payload.len() as u16).to_be_bytes());
    frame.extend_from_slice(&crc.to_be_bytes());
    frame.extend_from_slice(&payload);
    frame
}

// ---- trace header helper ----

// Return encoded CalcRequest plus trace id+timestamp

// ---- request decoder (mirror of decode_calc_response) ----
pub fn decode_calc_request(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcRequest, FrameError> {
    // backport-guards: request
    if frame.len() >= 4 {
        let ver = frame[2];
        if ver != 1 {
            return Err(FrameError::UnknownVersion(ver));
        }
        let typ = frame[3];
        if typ != 1 && typ != 2 {
            return Err(FrameError::UnknownType(typ));
        }
    }

    if frame.len() < 10 {
        return Err(FrameError::ShortHeader);
    }
    if u16::from_be_bytes([frame[0], frame[1]]) != SYNC {
        return Err(FrameError::BadSync);
    }

    let _ver = frame[2];
    let typ = frame[3];
    let len = u16::from_be_bytes([frame[4], frame[5]]) as usize;
    let got_crc = u32::from_be_bytes([frame[6], frame[7], frame[8], frame[9]]);

    let need = 10 + len;
    if frame.len() < need {
        return Err(FrameError::Length);
    }

    let payload = &frame[10..need];
    if crc32(payload) != got_crc {
        return Err(FrameError::Crc);
    }
    if typ != MsgType::CalcReq as u8 {
        return Err(FrameError::Length);
    }

    proto::rpmsg::calc::v1::CalcRequest::decode(payload).map_err(|_| FrameError::Decode)
}
// --- add/replace this in src/lib.rs ---
// -- canonical request encoder (defines `req` properly) --

// -- helper with a synthetic trace (proto no longer carries trace fields) --

// --- helper with a synthetic trace (proto no longer has trace fields) ---
// --- helper with a synthetic trace (proto no longer has trace fields) ---
// --- helper with a synthetic trace (proto no longer has trace fields) ---

// Canonical framed request: version(1) + protobuf payload + CRC32(payload)


pub fn encode_calc_request(a: u32, b: u32) -> Vec<u8> {
    let req = proto::rpmsg::calc::v1::CalcRequest {
        a,
        b,
        op: proto::rpmsg::calc::v1::calc_request::Op::Sum as i32,
    };
    let mut payload = Vec::new();
    req.encode(&mut payload).expect("encode");
    crate::wire::wrap_v1(&payload)
}
  ;
    let mut payload = Vec::new();
    req.encode(&mut payload).expect("encode");
    crate::wire::wrap_v1(&payload)

  ;
    let mut payload = Vec::new();
    req.encode(&mut payload).expect("encode");
    crate::wire::wrap_v1(&payload)

// Same frame, plus synthetic trace id and timestamp (ns since epoch)
pub fn encode_calc_request_with_trace(a: u32, b: u32) -> (Vec<u8>, Vec<u8>, u64) {
    let frame = encode_calc_request(a, b);
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("time");
    let ts_ns: u64 = now.as_nanos() as u64;
    let trace_id = ts_ns.to_le_bytes().to_vec();
    (frame, trace_id, ts_ns)
}
