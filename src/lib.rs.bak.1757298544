use prost::Message;

#[derive(Debug)]
pub enum FrameError {
    Decode,
    UnknownVersion(u8),
    TooShort,
    /// tests expect this exact variant on CRC failure
    Crc,
}

// ---- protobuf modules generated by prost-build ----
pub mod proto {
    pub mod rpmsg {
        pub mod calc {
            pub mod v1 {
                include!(concat!(env!("OUT_DIR"), "/rpmsg.calc.v1.rs"));
            }
        }
    }
}

// ---- crc utility ----
#[allow(dead_code)]
fn crc32(data: &[u8]) -> u32 {
    let mut h = crc32fast::Hasher::new();
    h.update(data);
    h.finalize()
}

// ---- public wire helpers used by tests ----
pub mod wire {
    use super::FrameError;

    pub const VER: u8 = 1;
    pub const PROTO_VERSION: u8 = VER;

    pub const TYPE_REQ:  u8 = 1;
    pub const TYPE_RESP: u8 = 2;

    #[inline]
    fn crc32_typed(typ: u8, payload: &[u8]) -> u32 {
        let mut h = crc32fast::Hasher::new();
        h.update(&[typ]);
        h.update(payload);
        h.finalize()
    }

    /// v1 frame = [version=1][type][payload...][crc32(type+payload) little-endian]
    pub fn wrap_v1_typed(typ: u8, payload: &[u8]) -> Vec<u8> {
        let mut out = Vec::with_capacity(1 + 1 + payload.len() + 4);
        out.push(VER);
        out.push(typ);
        out.extend_from_slice(payload);
        let c = crc32_typed(typ, payload);
        out.extend_from_slice(&c.to_le_bytes());
        out
    }

    pub fn wrap_v1_req(payload: &[u8]) -> Vec<u8>  { wrap_v1_typed(TYPE_REQ,  payload) }
    pub fn wrap_v1_resp(payload: &[u8]) -> Vec<u8> { wrap_v1_typed(TYPE_RESP, payload) }

    /// Validate frame for a specific expected type; CRC over (expected_type + payload)
    pub fn unwrap_v1_typed(frame: &[u8], expect_typ: u8) -> Result<&[u8], FrameError> {
        if frame.len() < 1 + 1 + 4 { return Err(FrameError::TooShort); }
        let ver = frame[0];
        if ver != PROTO_VERSION { return Err(FrameError::UnknownVersion(ver)); }

        // [ ver | type | payload... | crc32(type+payload) ]
        let payload_len = frame.len() - 1 - 1 - 4;
        let (payload, crc_bytes) = frame[2..].split_at(payload_len);
        if crc_bytes.len() != 4 { return Err(FrameError::TooShort); }

        let got = u32::from_le_bytes([crc_bytes[0], crc_bytes[1], crc_bytes[2], crc_bytes[3]]);
        let want = crc32_typed(expect_typ, payload);

        eprintln!(
            "DBG unwrap_v1_typed: len={} ver={} typ_actual={} expect_typ={} payload_len={} got={:#010x} want={:#010x} equal={}",
            frame.len(), ver, frame[1], expect_typ, payload_len, got, want, got == want
        );

        if got != want { return Err(FrameError::Crc); }
        Ok(payload)
    }
}
// ==== calc v1 encoders/decoders ====

pub fn encode_calc_request(a: u32, b: u32) -> Vec<u8> {
    let req = proto::rpmsg::calc::v1::CalcRequest {
        a,
        b,
        op: proto::rpmsg::calc::v1::calc_request::Op::Sum as i32,
    };
    let mut payload = Vec::new();
    req.encode(&mut payload).expect("encode");
    crate::wire::wrap_v1_req(&payload)
}

/// Canonical framed response: version(1) + protobuf payload + CRC32(payload)
pub fn encode_calc_response(sum: u32) -> Vec<u8> {
    let resp = proto::rpmsg::calc::v1::CalcResponse { result: sum };
    let mut payload = Vec::new();
    resp.encode(&mut payload).expect("encode");
    crate::wire::wrap_v1_resp(&payload)
}

/// Same frame, plus synthetic trace id and timestamp (ns since epoch)
pub fn encode_calc_request_with_trace(a: u32, b: u32) -> (Vec<u8>, Vec<u8>, u64) {
    let frame = encode_calc_request(a, b);
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("time");
    let ts_ns: u64 = now.as_nanos() as u64;
    let trace_id = ts_ns.to_le_bytes().to_vec();
    (frame, trace_id, ts_ns)
}

pub fn decode_calc_request(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcRequest, FrameError> {
    let payload = crate::wire::unwrap_v1_typed(frame, crate::wire::TYPE_REQ)?;
    proto::rpmsg::calc::v1::CalcRequest::decode(payload).map_err(|_| FrameError::Decode)
}

pub fn decode_calc_response(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcResponse, FrameError> {
    let payload = crate::wire::unwrap_v1_typed(frame, crate::wire::TYPE_RESP)?;
    proto::rpmsg::calc::v1::CalcResponse::decode(payload).map_err(|_| FrameError::Decode)
}
