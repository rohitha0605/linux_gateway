use tracing_subscriber::util::SubscriberInitExt;
#[derive(Deserialize)]
struct EncodeReq {
    a: u32,
    b: u32,
}

#[derive(Serialize)]
struct EncodeResp {
    a: u32,
    b: u32,
    frame_hex: String,
}

#[derive(Deserialize)]
struct DecodeReq {
    frame_hex: String,
}

#[derive(Serialize)]
struct DecodeResp {
    sum: Option<u32>,
    error: Option<String>,
    trace_id_hex: Option<String>,
    ts_ns: Option<u64>,
}
use linux_gateway::encode_calc_request;
use serde::{Deserialize, Serialize};

    // ---- exporter (HTTP → Jaeger OTLP at 4318) ----
fn init_tracing() -> anyhow::Result<()> {
    use opentelemetry::{global, KeyValue};
    use opentelemetry_sdk::{
        propagation::TraceContextPropagator,
        resource::Resource,
        trace::SdkTracerProvider,
    };
    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

    // Endpoint: Jaeger all-in-one HTTP OTLP receiver (4318)
    let endpoint = std::env::var("OTEL_EXPORTER_OTLP_TRACES_ENDPOINT")
        .unwrap_or_else(|_| "http://127.0.0.1:4318/v1/traces".to_string());

    // Build HTTP exporter
    let exporter = opentelemetry_otlp::SpanExporter::builder()
        .with_http()
        .with_endpoint(endpoint)
        .build()?;

    // Provider + resource (service.name)
    let provider = SdkTracerProvider::builder()
        .with_resource(
            Resource::builder()
                .with_service_name("linux_gateway")
                .with_attributes([KeyValue::new("service.name", "linux_gateway")])
                .build(),
        )
        .with_batch_exporter(exporter)
        .build();

    // Set global provider & W3C propagator
    global::set_tracer_provider(provider.clone());
    global::set_text_map_propagator(TraceContextPropagator::new());

    // Bridge tracing → OpenTelemetry and install subscriber
    let tracer = provider.tracer("linux_gateway");
    let otel_layer = tracing_opentelemetry::layer().with_tracer(tracer);

    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer())
        .with(otel_layer)
        .try_init()?;

    Ok(())
}
async fn run_server() -> anyhow::Result<()> {
    use axum::{routing::post, Router};
    use tower_http::trace::{DefaultMakeSpan, DefaultOnResponse, TraceLayer};
    use tracing::Level;

    // these handlers should already exist in your file
    //   async fn encode_calc_http(Json(req): Json<EncodeReq>) -> Json<EncodeResp> { ... }
    //   async fn decode_calc_http(Json(req): Json<DecodeReq>) -> Json<DecodeResp> { ... }

    let app = Router::new()
        .route("/encode_calc", post(encode_calc_http))
        .route("/decode_calc", post(decode_calc_http))
        .layer(
            TraceLayer::new_for_http()
                .make_span_with(DefaultMakeSpan::new().level(Level::INFO))
                .on_response(DefaultOnResponse::new().level(Level::INFO)),
        );

    let listener = tokio::net::TcpListener::bind("127.0.0.1:8080").await?;
    axum::serve(listener, app).await?;
    Ok(())
}

async fn encode_calc_http(axum::Json(req): axum::Json<EncodeReq>) -> axum::Json<EncodeResp> {
    let frame = encode_calc_request(req.a, req.b);
    axum::Json(EncodeResp {
        a: req.a,
        b: req.b,
        frame_hex: hex::encode_upper(frame),
    })
}

#[tracing::instrument(name="decode_calc", skip(req), fields(len = req.frame_hex.len()))]
async fn decode_calc_http(axum::Json(req): axum::Json<DecodeReq>) -> axum::Json<DecodeResp> {
    match hex::decode(&req.frame_hex)
        .ok()
        .and_then(|d| linux_gateway::decode_calc_response(&d).ok())
    {
        Some(resp) => {
            let (trace_id_hex, ts_ns) = match resp.trace {
                Some(t) => (Some(hex::encode_upper(t.id)), Some(t.ts_ns)),
                None => (None, None),
            };
            axum::Json(DecodeResp {
                sum: Some(resp.sum),
                error: None,
                trace_id_hex,
                ts_ns,
            })
        }
        None => axum::Json(DecodeResp {
            sum: None,
            error: Some("decode error".into()),
            trace_id_hex: None,
            ts_ns: None,
        }),
    }
}
fn main() {
    init_tracing().expect("otel tracing init");
    // init tracing once (don’t crash if it fails)
    if let Err(e) = init_tracing() {
        eprintln!("tracing init failed: {e}");
    }

    let args: Vec<String> = std::env::args().collect();
    if args.get(1).map(|s| s == "serve").unwrap_or(false) {
        let rt = tokio::runtime::Runtime::new().expect("rt");
        if let Err(e) = rt.block_on(run_server()) {
            eprintln!("server error: {e:?}");
        }
    } else {
        eprintln!("usage: {} serve", args[0]);
    }
}
fn init_tracing() -> anyhow::Result<()> {
    use opentelemetry::global;
    use opentelemetry::trace::TracerProvider as _;            // enables .tracer(...)
    use opentelemetry_otlp::{SpanExporter, WithExportConfig};  // enables .with_endpoint(...)
    use opentelemetry_sdk::{
        propagation::TraceContextPropagator,
        trace::SdkTracerProvider,
    };
    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

    // Default to Jaeger OTLP/HTTP
    let endpoint = std::env::var("OTEL_EXPORTER_OTLP_TRACES_ENDPOINT")
        .unwrap_or_else(|_| "http://127.0.0.1:4318/v1/traces".to_string());

    let exporter = SpanExporter::builder()
        .with_http()
        .with_endpoint(endpoint)
        .build()?;

    let provider = SdkTracerProvider::builder()
        .with_batch_exporter(exporter)
        .build();

    // Make global + W3C propagation
    let _ = global::set_tracer_provider(provider.clone());
    global::set_text_map_propagator(TraceContextPropagator::new());

    // Bridge tracing -> OTel
    let tracer = provider.tracer("linux_gateway");
    let otel_layer = tracing_opentelemetry::layer().with_tracer(tracer);

    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer())
        .with(otel_layer)
        .try_init()?; // idempotent

    Ok(())
}
