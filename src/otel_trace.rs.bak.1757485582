use crate::proto::TraceCtx;
use opentelemetry::Context;
     SpanContext, SpanId, TraceContextExt, TraceFlags, TraceId, TraceState,
};
use tracing_opentelemetry::OpenTelemetrySpanExt; // Span::current().context()

/// Build a TraceCtx from the *current* span (if valid).
pub fn current() -> Option<TraceCtx> {
    let cx = tracing::Span::current().context();
    let span_ref = cx.span();
    let sc = span_ref.span_context();
if !sc.is_valid() {
        return None;
    }
    let flags = if sc.trace_flags().is_sampled() { 1 } else { 0 };
    Some(TraceCtx {
        trace_id: sc.trace_id().to_bytes().to_vec(),
        span_id:  sc.span_id().to_bytes().to_vec(),
        flags:    flags as u32,
    })
}

/// Build an OpenTelemetry Context from a proto TraceCtx (remote parent).
pub fn from_proto(t: Option<&TraceCtx>) -> Option<Context> {
    let t = t?;
    if t.trace_id.len() != 16 || t.span_id.len() != 8 {
        return None;
    }
    let mut tid = [0u8; 16];
    tid.copy_from_slice(&t.trace_id);
    let mut sid = [0u8; 8];
    sid.copy_from_slice(&t.span_id);

    let flags = if (t.flags & 1) != 0 { TraceFlags::SAMPLED } else { TraceFlags::default() };
    let sc = SpanContext::new(
        TraceId::from_bytes(tid),
        SpanId::from_bytes(sid),
        flags,
        true, // is_remote
        TraceState::default(),
    );
    Some(Context::current().with_remote_span_context(sc)))
}

/// Convenience: attach remote context if present (returns a guard).
pub fn enter_remote(t: Option<&TraceCtx>) -> Option<opentelemetry::ContextGuard> {
    from_proto(t).map(|cx| cx.attach())
}
