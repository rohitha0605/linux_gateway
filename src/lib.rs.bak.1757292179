use prost::Message;

#[derive(Debug)]
pub enum FrameError {
    Decode,
    UnknownVersion(u8),
    TooShort,
    /// tests expect this exact variant on CRC failure
    Crc,
}

// ---- protobuf modules generated by prost-build ----
pub mod proto {
    pub mod rpmsg {
        pub mod calc {
            pub mod v1 {
                include!(concat!(env!("OUT_DIR"), "/rpmsg.calc.v1.rs"));
            }
        }
    }
}

// ---- crc utility ----
fn crc32(data: &[u8]) -> u32 {
    let mut h = crc32fast::Hasher::new();
    h.update(data);
    h.finalize()
}

// ---- public wire helpers used by tests ----
pub mod wire {
    use super::{crc32, FrameError};

    pub const VER: u8 = 1;
    pub const PROTO_VERSION: u8 = VER;

    /// v1 frame = [version=1][payload...][crc32(payload) little-endian]
    pub fn wrap_v1(payload: &[u8]) -> Vec<u8> {
        let mut out = Vec::with_capacity(1 + payload.len() + 4);
        out.push(VER);
        out.extend_from_slice(payload);
        let c = crc32(payload);
        out.extend_from_slice(&c.to_le_bytes());
        out
    }

    /// Return the payload slice if the frame is well-formed (version + CRC verified).
    pub fn unwrap_v1(frame: &[u8]) -> Result<&[u8], FrameError> {
        if frame.len() < 1 + 4 { return Err(FrameError::TooShort); }
        let ver = frame[0];
        if ver != PROTO_VERSION { return Err(FrameError::UnknownVersion(ver)); }

        // [ ver | payload... | crc32(payload LE) ]
        let payload_len = frame.len() - 1 - 4;
        let (payload, crc_bytes) = frame[1..].split_at(payload_len);
        if crc_bytes.len() != 4 { return Err(FrameError::TooShort); }

        let got = u32::from_le_bytes([crc_bytes[0], crc_bytes[1], crc_bytes[2], crc_bytes[3]]);
        let want = crc32(payload);

        // Leave this on while debugging the failing test
        eprintln!("DBG unwrap_v1: len={} ver={} payload_len={} got={:#010x} want={:#010x} equal={}",
            frame.len(), ver, payload_len, got, want, got == want);

        if got != want { return Err(FrameError::Crc); }
        Ok(payload)
    }
}

// ==== calc v1 encoders/decoders ====

pub fn encode_calc_request(a: u32, b: u32) -> Vec<u8> {
    let req = proto::rpmsg::calc::v1::CalcRequest {
        a,
        b,
        op: proto::rpmsg::calc::v1::calc_request::Op::Sum as i32,
    };
    let mut payload = Vec::new();
    req.encode(&mut payload).expect("encode");
    wire::wrap_v1(&payload)
}

/// Canonical framed response: version(1) + protobuf payload + CRC32(payload)
pub fn encode_calc_response(sum: u32) -> Vec<u8> {
    let resp = proto::rpmsg::calc::v1::CalcResponse { result: sum };
    let mut payload = Vec::new();
    resp.encode(&mut payload).expect("encode");
    wire::wrap_v1(&payload)
}

/// Same frame, plus synthetic trace id and timestamp (ns since epoch)
pub fn encode_calc_request_with_trace(a: u32, b: u32) -> (Vec<u8>, Vec<u8>, u64) {
    let frame = encode_calc_request(a, b);
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("time");
    let ts_ns: u64 = now.as_nanos() as u64;
    let trace_id = ts_ns.to_le_bytes().to_vec();
    (frame, trace_id, ts_ns)
}

pub fn decode_calc_request(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcRequest, FrameError> {
    let payload = wire::unwrap_v1(frame)?;
    proto::rpmsg::calc::v1::CalcRequest::decode(payload).map_err(|_| FrameError::Decode)
}

pub fn decode_calc_response(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcResponse, FrameError> {
    let payload = wire::unwrap_v1(frame)?;
    proto::rpmsg::calc::v1::CalcResponse::decode(payload).map_err(|_| FrameError::Decode)
}
