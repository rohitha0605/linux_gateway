use crc32fast::Hasher;

/// Protocol frame version we emit/accept.
pub const PROTO_VERSION: u8 = 1;

/// Compute CRC32 of a byte slice (little-endian used in frames).
pub fn crc32(bytes: &[u8]) -> u32 {
    let mut h = Hasher::new();
    h.update(bytes);
    h.finalize()
}

/// v1 frame = [version=1][payload...][crc32(payload) little-endian]
pub fn wrap_v1(payload: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(1 + payload.len() + 4);
    out.push(PROTO_VERSION);
    out.extend_from_slice(payload);
    out.extend_from_slice(&crc32(payload).to_le_bytes());
    out
}

/// Validate a v1 frame and return the payload slice.
pub fn unwrap_v1(frame: &[u8]) -> Result<&[u8], &'static str> {
    if frame.len() < 1 + 4 { return Err("frame too short"); }
    if frame[0] != PROTO_VERSION { return Err("wrong version"); }
    let payload_len = frame.len() - 1 - 4;
    let (payload, crc_bytes) = frame[1..].split_at(payload_len);
    let got = u32::from_le_bytes([crc_bytes[0], crc_bytes[1], crc_bytes[2], crc_bytes[3]]);
    if got != crc32(payload) { return Err("crc mismatch"); }
    Ok(payload)
}
