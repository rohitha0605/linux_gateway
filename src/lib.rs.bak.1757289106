#[derive(Debug)]
pub enum FrameError {
    Decode,
    UnknownVersion(u8),
    TooShort,
    Length,
    BadCrc { got: u32, want: u32 },
}

fn crc32(data: &[u8]) -> u32 {
    let mut h = Hasher::new();
    h.update(data);
    h.finalize()
}

// Generated by prost in build.rs
pub mod proto {
    pub mod rpmsg {
        pub mod calc {
            pub mod v1 {
                include!(concat!(env!("OUT_DIR"), "/rpmsg.calc.v1.rs"));
            }
        }
    }
}



UnknownVersion(u8),
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcResponse, FrameError> {
    // backport-guards: response
    if frame.len() >= 4 {
        let ver = frame[2];
        if ver != 1 {
            return Err(FrameError::UnknownVersion(ver));
        }
        let typ = frame[3];
        if typ != 1 && typ != 2 {
            return Err(FrameError::UnknownType(typ));
        }
    }

    if frame.len() < 10 {
        return Err(FrameError::ShortHeader);
    }
    if frame.len() < need {
        return Err(FrameError::Length);
    }

    let payload = &frame[10..need];
    if crc32(payload) != got_crc {
        return Err(FrameError::Crc);
    }
    if typ != MsgType::CalcReq as u8 {
        return Err(FrameError::Length);
    }

    proto::rpmsg::calc::v1::CalcRequest::decode(payload).map_err(|_| FrameError::Decode)
}
// --- add/replace this in src/lib.rs ---
// -- canonical request encoder (defines `req` properly) --

// -- helper with a synthetic trace (proto no longer carries trace fields) --

// --- helper with a synthetic trace (proto no longer has trace fields) ---
// --- helper with a synthetic trace (proto no longer has trace fields) ---
// --- helper with a synthetic trace (proto no longer has trace fields) ---

// Canonical framed request: version(1) + protobuf payload + CRC32(payload)



// ==== calc v1 encoders ====

pub fn encode_calc_request(a: u32, b: u32) -> Vec<u8> {
    let req = proto::rpmsg::calc::v1::CalcRequest {
        a,
        b,
        op: proto::rpmsg::calc::v1::calc_request::Op::Sum as i32,
    };
    let mut payload = Vec::new();
    req.encode(&mut payload).expect("encode");
    crate::wire::wrap_v1(&payload)
}

// Same frame, plus synthetic trace id and timestamp (ns since epoch)
pub fn encode_calc_request_with_trace(a: u32, b: u32) -> (Vec<u8>, Vec<u8>, u64) {
    let frame = encode_calc_request(a, b);
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("time");
    let ts_ns: u64 = now.as_nanos() as u64;
    let trace_id = ts_ns.to_le_bytes().to_vec();
    (frame, trace_id, ts_ns)
}

// === canonical v1 decoders that match wire.rs ===
// === canonical v1 decoders that match wire.rs ===
// === canonical v1 decoders that use wire::unwrap_v1 (typed errors) ===
// === canonical v1 decoders ===
pub fn decode_calc_request(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcRequest, FrameError> {
    let payload = crate::wire::unwrap_v1(frame)?;
    proto::rpmsg::calc::v1::CalcRequest::decode(payload).map_err(|_| FrameError::Decode)
}

pub fn decode_calc_response(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcResponse, FrameError> {
    let payload = crate::wire::unwrap_v1(frame)?;
    proto::rpmsg::calc::v1::CalcResponse::decode(payload).map_err(|_| FrameError::Decode)
}
