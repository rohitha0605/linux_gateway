
mod telemetry;
use std::env;
use std::process;

const HELP: &str = "Usage:
  linux_gateway --decode HEX
  linux_gateway make-resp <SUM>
  linux_gateway make-req-trace <A> <B>
  linux_gateway rpmsg-bounce <HEX>
  linux_gateway --version
";

fn parse_hex(s: &str) -> Result<Vec<u8>, ()> {
    if s.len() % 2 != 0 {
        return Err(());
    }
    let mut out = Vec::with_capacity(s.len() / 2);
    let bytes = s.as_bytes();
    let mut i = 0;
    while i < s.len() {
        let hi = (bytes[i] as char).to_digit(16).ok_or(())?;
        let lo = (bytes[i + 1] as char).to_digit(16).ok_or(())?;
        out.push(((hi << 4) | lo) as u8);
        i += 2;
    }
    Ok(out)
}

#[tokio::main]
async fn main() {
    let _ = telemetry::init("linux_gateway");
    let _cli_span = tracing::info_span!("cli");
    let _cli_enter = _cli_span.enter();
let argv: Vec<String> = env::args().collect();
    // rpmsg-bounce <HEX>  -> decode request, echo trace, encode response
    if argv.len() == 3 && argv[1] == "rpmsg-bounce" {
        let hex_arg = &argv[2];
        let data = match hex::decode(hex_arg) {
            Ok(d) => d,
            Err(e) => { eprintln!("HEX_DECODE_ERR={}", e); std::process::exit(2) }
        };
        match linux_gateway::decode_calc_request(&data) {
            Ok(req) => {
                                let r5_span = tracing::info_span!("r5_compute", a = req.a, b = req.b);
                let _r5_enter = r5_span.enter();
let r5_span = tracing::info_span!("r5_compute", a = req.a, b = req.b);
                let _r5_enter = r5_span.enter();
                let span = tracing::info_span!("r5_compute", a = req.a, b = req.b);
                let _e = span.enter();
                let t0 = std::time::Instant::now();
                let sum = (req.a as i64 + req.b as i64) as i32;
                let resp = linux_gateway::proto::CalcResponse {
                    result: sum,
                    trace: req.trace.clone(),   // echo the incoming trace
                };
                let frame = linux_gateway::encode_calc_response(sum as u32);
                
                let tid_hex = req.trace.as_ref().map(|t| hex::encode_upper(&t.trace_id));
                tracing::info!(elapsed_ms = t0.elapsed().as_millis() as u64, result = sum, trace_id = tid_hex.as_deref().unwrap_or(""), "r5_compute_done");
                println!("{}", hex::encode_upper(frame));
}
            Err(e) => { eprintln!("DECODE_REQ_ERR={}", e); std::process::exit(1) }
        }
        return;
    }
    if argv.len() == 1 || argv[1] == "-h" || argv[1] == "--help" {
        println!("{}", HELP);
        return;
    }

    if argv[1] == "--version" || argv[1] == "-V" {
        println!("{}", env!("CARGO_PKG_VERSION"));
        return;
    }

    match argv[1].as_str() {
        s if s.starts_with("--decode") => {
            let val = if let Some(eq) = s.strip_prefix("--decode=") {
                eq.to_string()
            } else if s == "--decode" && argv.len() >= 3 {
                argv[2].clone()
            } else {
                eprintln!("{}", HELP);
                process::exit(2);
            };
            if parse_hex(&val).is_err() {
                eprintln!("decode: invalid hex");
                process::exit(2);
            }
        }
        "make-resp" | "make_resp" => {
            if argv.len() < 3 {
                eprintln!("{}", HELP);
                process::exit(2);
            }
            let sum: u32 = match argv[2].parse() {
                Ok(v) => v,
                Err(_) => {
                    eprintln!("make-resp: invalid number");
                    process::exit(2);
                }
            };
            let frame = linux_gateway::encode_calc_response(sum);
            let mut s = String::with_capacity(frame.len() * 2);
            for b in frame {
                s.push_str(&format!("{:02X}", b));
            }
            println!("{}", s);
        }
        "make-req-trace" | "make_req_trace" => {
            if argv.len() < 4 {
                eprintln!("{}", HELP);
                process::exit(2);
            }
            let a: u32 = argv[2].parse().unwrap_or_else(|_| {
                eprintln!("invalid A");
                process::exit(2);
            });
            let b: u32 = argv[3].parse().unwrap_or_else(|_| {
                eprintln!("invalid B");
                process::exit(2);
            });
            let frame = linux_gateway::encode_calc_request(a, b);
            let mut s = String::with_capacity(frame.len() * 2);
            for b in frame {
                s.push_str(&format!("{:02X}", b));
            }
            println!("{}", s);
        }
        "rpmsg-bounce" | "rpmsg_bounce" => {
            if argv.len() < 3 {
                eprintln!("rpmsg-bounce: missing HEX argument");
                process::exit(2);
            }
            if parse_hex(&argv[2]).is_err() {
                eprintln!("rpmsg-bounce: invalid hex");
                process::exit(2);
            }
        }
        _ => {
            println!("{}", HELP);
            process::exit(2);
        }
    }
}
