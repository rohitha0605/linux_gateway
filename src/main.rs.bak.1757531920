mod telemetry;
use std::env;

const HELP: &str = "Usage:
  linux_gateway --decode HEX
  linux_gateway make-resp <SUM>
  linux_gateway make-req-trace <A> <B>
  linux_gateway rpmsg-bounce <HEX>
  linux_gateway --version
";

fn parse_hex(s: &str) -> Result<Vec<u8>, ()> {
    if s.len() % 2 != 0 { return Err(()); }
    let mut out = Vec::with_capacity(s.len() / 2);
    let bytes = s.as_bytes();
    let mut i = 0;
    while i < s.len() {
        let hi = (bytes[i] as char).to_digit(16).ok_or(())?;
        let lo = (bytes[i + 1] as char).to_digit(16).ok_or(())?;
        out.push(((hi << 4) | lo) as u8);
        i += 2;
    }
    Ok(out)
}

#[tokio::main]
async fn main() {
    let _ = telemetry::init("linux_gateway");
    let cli_span = tracing::info_span!("cli");
    let _cli_enter = cli_span.enter();

    let argv: Vec<String> = env::args().collect();

    // rpmsg-bounce <HEX>  -> decode request, compute, echo trace, encode response
    if argv.len() == 3 && argv[1] == "rpmsg-bounce" {
    let hex_arg = &argv[2];
    let data = match hex::decode(hex_arg) {
        Ok(d) => d,
        Err(e) => { eprintln!("HEX_DECODE_ERR={e}"); std::process::exit(2) }
    };

    match linux_gateway::decode_calc_request(&data) {
        

    Ok(req) => {
                let _remote_guard = linux_gateway::otel_trace::enter_remote(req.trace.as_ref());
                let r5_span = tracing::info_span!("r5_compute", a = req.a, b = req.b);
                let _r5_enter = r5_span.enter();
let r5_span = tracing::info_span!("r5_compute", a = req.a, b = req.b);
                let _r5_enter = r5_span.enter();
// Make r5_compute a child of the incoming remote parent
    let _remote_guard = linux_gateway::otel_trace::enter_remote(req.trace.as_ref());
    let r5_span = tracing::info_span!("r5_compute", a = req.a, b = req.b);
  let _r5_enter = r5_span.enter();
// Attach incoming TraceCtx as remote parent so we keep the SAME trace.
            let _remote_guard = (|| {
                if let Some(t) = &req.trace {
                    use opentelemetry::trace::{
                        SpanContext, TraceContextExt, TraceFlags, TraceId, SpanId, TraceState,
                    };

                    let mut tid = [0u8; 16];
                    let mut sid = [0u8; 8];
                    let tn = t.trace_id.len().min(16);
                    let sn = t.span_id.len().min(8);
                    tid[..tn].copy_from_slice(&t.trace_id[..tn]);
                    sid[..sn].copy_from_slice(&t.span_id[..sn]);

                    let sc = SpanContext::new(
                        TraceId::from_bytes(tid),
                        SpanId::from_bytes(sid),
                        TraceFlags::new((t.flags as u8) & 0x01),
                        /*remote:*/ true,
                        TraceState::default(),
                    );
                    let cx = opentelemetry::Context::current().with_remote_span_context(sc);
                    Some(cx.attach())
                } else {
                    None
                }
            })();

            // Child span that represents the "R5 compute" work
            let t0 = std::time::Instant::now();
            let sum = (req.a as i64 + req.b as i64) as i32;

            // IMPORTANT: keep the standard framed response
                let resp = linux_gateway::proto::CalcResponse {
                    result: sum,                  // sum is i32 here
                    trace: None,     // echo the incoming trace
                };
                let resp = linux_gateway::proto::CalcResponse {
                    result: sum,                  // i32
                    trace: None,     // echo the incoming trace
                };
                let resp = linux_gateway::proto::CalcResponse {
                    result: sum,              // i32
                    trace: None, // echo incoming TraceCtx
                };
                let frame = linux_gateway::encode_calc_response(&resp);

            // Log (to stderr if you enable it below) and print HEX to stdout
            let tid_hex = req.trace.as_ref().map(|t| hex::encode_upper(&t.trace_id));
            tracing::info!(
                elapsed_ms = t0.elapsed().as_millis() as u64,
                result = sum,
                trace_id = tid_hex.as_deref().unwrap_or(""),
                "r5_compute_done"
            );
            println!("{}", hex::encode_upper(frame));
        }
        Err(e) => { eprintln!("DECODE_REQ_ERR={e}"); std::process::exit(1) }
    }
    return;
}


    if argv.len() == 1 || argv[1] == "-h" || argv[1] == "--help" {
        println!("{HELP}");
        return;
    }

    if argv[1] == "--version" || argv[1] == "-V" {
        println!("{}", env!("CARGO_PKG_VERSION"));
        return;
    }

    match argv[1].as_str() {
        s if s.starts_with("--decode") => {
            let val = if let Some(eq) = s.strip_prefix("--decode=") {
                eq.to_string()
            } else if s == "--decode" && argv.len() >= 3 {
                argv[2].clone()
            } else {
                eprintln!("{HELP}");
                std::process::exit(2);
            };
            if parse_hex(&val).is_err() {
                eprintln!("decode: invalid hex");
                std::process::exit(2);
            }
        }
        "make-resp" | "make_resp" => {
            if argv.len() < 3 {
                eprintln!("{HELP}");
                std::process::exit(2);
            }
            let sum: u32 = match argv[2].parse() {
                Ok(v) => v,
                Err(_) => { eprintln!("make-resp: invalid number"); std::process::exit(2); }
            };
            let resp = linux_gateway::proto::
    
            let resp = linux_gateway::proto::CalcResponse {
                result: sum as i32,   // parsed as u32; store as i32
                trace: None,
            };
            let frame = linux_gateway::encode_calc_response(&resp);
            println!("{}", hex::encode_upper(frame));
        }
        "make-req-trace" | "make_req_trace" => {
            let make_span = tracing::info_span!("linux_request");
            let _enter = make_span.enter();
            if argv.len() < 4 {
                eprintln!("{HELP}");
                std::process::exit(2);
            }
            let a: i32 = argv[2].parse().unwrap_or_else(|_| { eprintln!("invalid A"); std::process::exit(2); });
            let b: i32 = argv[3].parse().unwrap_or_else(|_| { eprintln!("invalid B"); std::process::exit(2); });
            let frame = 
linux_gateway::encode_calc_request(a, b, linux_gateway::otel_trace::current());
            println!("{}", hex::encode_upper(frame));
        }
        _ => {
            println!("{HELP}");
            std::process::exit(2);
        }
    }
}
