use bytes::{BufMut, BytesMut};
use crc32fast::Hasher;
use prost::Message;
use thiserror::Error;

// --- framing constants ---
const SYNC: u16 = 0xA55A;
const VER: u8 = 0x01;

#[repr(u8)]
enum MsgType {
    CalcReq = 1,
    CalcResp = 2,
}

fn crc32(data: &[u8]) -> u32 {
    let mut h = Hasher::new();
    h.update(data);
    h.finalize()
}

// Generated by prost in build.rs
pub mod proto {
    pub mod rpmsg {
        pub mod calc {
            pub mod v1 {
                include!(concat!(env!("OUT_DIR"), "/rpmsg.calc.v1.rs"));
            }
        }
    }
}

#[derive(Debug, Error)]
pub enum FrameError {
    #[error("short header")]
    ShortHeader,
    #[error("bad sync")]
    BadSync,
    #[error("length mismatch")]
    Length,
    #[error("crc mismatch")]
    Crc,
    #[error("{0}")]
    ProstDecode(#[from] prost::DecodeError),
}

pub fn encode_calc_request(a: u32, b: u32) -> Vec<u8> {
    let req = proto::rpmsg::calc::v1::CalcRequest { a, b, trace: None };
    let mut payload = Vec::with_capacity(8);
    req.encode(&mut payload).expect("encode");

    let mut buf = BytesMut::with_capacity(10 + payload.len());
    buf.put_u16(SYNC);
    buf.put_u8(VER);
    buf.put_u8(MsgType::CalcReq as u8);
    buf.put_u16(payload.len() as u16);
    buf.put_u32(crc32(&payload));
    buf.extend_from_slice(&payload);
    buf.to_vec()
}

pub fn decode_calc_response(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcResponse, FrameError> {
    if frame.len() < 10 {
        return Err(FrameError::ShortHeader);
    }
    if u16::from_be_bytes([frame[0], frame[1]]) != SYNC {
        return Err(FrameError::BadSync);
    }

    let _ver = frame[2];
    let typ = frame[3];
    let len = u16::from_be_bytes([frame[4], frame[5]]) as usize;
    let got_crc = u32::from_be_bytes([frame[6], frame[7], frame[8], frame[9]]);

    let need = 10 + len;
    if frame.len() < need {
        return Err(FrameError::Length);
    }

    let payload = &frame[10..need];
    if crc32(payload) != got_crc {
        return Err(FrameError::Crc);
    }
    if typ != MsgType::CalcResp as u8 {
        return Err(FrameError::Length);
    }

    Ok(proto::rpmsg::calc::v1::CalcResponse::decode(payload)?)
}

pub fn encode_calc_response(sum: u32) -> Vec<u8> {
    let resp = proto::rpmsg::calc::v1::CalcResponse {
        sum,
        trace: Some(gen_trace_header()),
    };
    let mut payload = Vec::with_capacity(8);
    resp.encode(&mut payload).expect("encode");

    let crc = crc32(&payload);
    let mut frame = Vec::with_capacity(10 + payload.len());
    frame.extend_from_slice(&SYNC.to_be_bytes());
    frame.push(VER);
    frame.push(MsgType::CalcResp as u8);
    frame.extend_from_slice(&(payload.len() as u16).to_be_bytes());
    frame.extend_from_slice(&crc.to_be_bytes());
    frame.extend_from_slice(&payload);
    frame
}

// ---- trace header helper ----
pub fn gen_trace_header() -> proto::rpmsg::calc::v1::TraceHeader {
    use rand::RngCore;
    use std::time::{SystemTime, UNIX_EPOCH};
    let mut id = [0u8; 16];
    rand::thread_rng().fill_bytes(&mut id);
    let ts_ns = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_nanos() as u64;
    proto::rpmsg::calc::v1::TraceHeader {
        id: id.to_vec(),
        ts_ns,
    }
}

// Return encoded CalcRequest plus trace id+timestamp
pub fn encode_calc_request_with_trace(a: u32, b: u32) -> (Vec<u8>, Vec<u8>, u64) {
    let trace = gen_trace_header();
    let req = proto::rpmsg::calc::v1::CalcRequest {
        a,
        b,
        trace: Some(trace.clone()),
    };

    let mut payload = Vec::with_capacity(req.encoded_len());
    req.encode(&mut payload).expect("encode request");

    let crc = crc32(&payload);

    let mut frame = Vec::with_capacity(10 + payload.len());
    frame.extend_from_slice(&SYNC.to_be_bytes());
    frame.push(VER);
    frame.push(MsgType::CalcReq as u8);
    frame.extend_from_slice(&(payload.len() as u16).to_be_bytes());
    frame.extend_from_slice(&crc.to_be_bytes());
    frame.extend_from_slice(&payload);

    (frame, trace.id, trace.ts_ns)
}

// ---- request decoder (mirror of decode_calc_response) ----
pub fn decode_calc_request(
    frame: &[u8],
) -> Result<proto::rpmsg::calc::v1::CalcRequest, FrameError> {
    if frame.len() < 10 { return Err(FrameError::ShortHeader); }
    if u16::from_be_bytes([frame[0], frame[1]]) != SYNC { return Err(FrameError::BadSync); }

    let _ver = frame[2];
    let typ = frame[3];
    let len = u16::from_be_bytes([frame[4], frame[5]]) as usize;
    let got_crc = u32::from_be_bytes([frame[6], frame[7], frame[8], frame[9]]);

    let need = 10 + len;
    if frame.len() < need { return Err(FrameError::Length); }

    let payload = &frame[10..need];
    if crc32(payload) != got_crc { return Err(FrameError::Crc); }
    if typ != MsgType::CalcReq as u8 { return Err(FrameError::Length); }

    Ok(proto::rpmsg::calc::v1::CalcRequest::decode(payload)?)
}
