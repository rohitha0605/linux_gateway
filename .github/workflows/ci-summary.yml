name: CI Summary
on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  workflow_dispatch:
    inputs:
      run_id:
        description: "CI run id to aggregate (optional)"
        required: false

permissions:
  actions: read
  contents: read

jobs:
  aggregate:
    runs-on: ubuntu-latest
    env:
      REPO: ${{ github.repository }}
      COVERAGE_MIN: "30"8"
      GH_TOKEN: ${{ github.token }}

    steps:
      - name: Resolve run_id
        shell: bash
        env:
          WF_NAME: "CI"
        run: |
          set -euo pipefail
          RID=""
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            RID="${{ github.event.workflow_run.id }}"
          fi
          if [ -z "${RID}" ] && [ -n "${{ inputs.run_id }}" ]; then
            RID="${{ inputs.run_id }}"
          fi
          if [ -z "${RID}" ]; then
            RID="$(gh run list -R "$REPO" --json databaseId,headSha,workflowName -L 50 \
                  --jq ".[] | select(.headSha==\"$GITHUB_SHA\" and .workflowName==\"${WF_NAME}\") | .databaseId" \
                  | head -n1 || true)"
          fi
          if [ -z "${RID}" ]; then
            echo "::error::No run_id to aggregate for $GITHUB_SHA (workflow '${WF_NAME}' not found)."
            exit 1
          fi
          echo "RID=$RID"

      - name: List artifacts on the CI run
        run: |
          gh api "repos/${REPO}/actions/runs/${RID}/artifacts" \
            --jq '{count: .total_count, names: [.artifacts[].name]}'

      - name: Download artifacts from the CI run
        run: |
          mkdir -p artifacts
          if ! gh run download -R "$REPO" "$RID" -D artifacts; then
            echo "::error::Download failed or no artifacts present for run $RID"
            exit 1
          fi
          echo "Downloaded files:"
          find artifacts -type f | sed 's/^/ - /'

      - name: JUnit summary (fail on failures/errors)
        shell: bash
        run: |
          python3 - <<'PY' | tee -a "$GITHUB_STEP_SUMMARY"
import os, sys, xml.etree.ElementTree as ET
paths=[]
for r,_,fs in os.walk('artifacts'):
    for fn in fs:
        if fn.endswith('.xml') and ('junit' in fn or 'test-results' in r or 'surefire' in r or 'failsafe' in r):
            paths.append(os.path.join(r,fn))
if not paths:
    print("[CI] JUnit: 0 tests, 0 failures, 0 errors, 0 skipped"); sys.exit(0)
T=F=E=S=0
for p in paths:
    try:
        root=ET.parse(p).getroot()
    except Exception:
        continue
    suites=[root] if root.tag.endswith('testsuite') else root.findall('.//testsuite')
    for ts in suites:
        T+=int(ts.attrib.get('tests',0) or 0)
        F+=int(ts.attrib.get('failures',0) or 0)
        E+=int(ts.attrib.get('errors',0) or 0)
        S+=int(ts.attrib.get('skipped',0) or 0)
msg=f"[CI] JUnit: {T} tests, {F} failures, {E} errors, {S} skipped"
print(msg)
print("### CI Summary\n\n- "+msg[5:]+"\n")
if F>0 or E>0: sys.exit(1)
PY

      - name: Coverage summary (LCOV â†’ JaCoCo XML fallback)
        shell: bash
        run: |
          set -euo pipefail
          : "${GITHUB_STEP_SUMMARY:=/tmp/STEP_SUMMARY.md}"
          python3 - <<'PY'
import glob, xml.etree.ElementTree as ET, os, sys
# Try LCOV first
LF=LH=0
for fp in glob.glob('artifacts/**/lcov.info', recursive=True):
    try:
        with open(fp, encoding="utf-8", errors="ignore") as fh:
            for line in fh:
                if line.startswith('LF:'): LF += int(line.split(':',1)[1])
                elif line.startswith('LH:'): LH += int(line.split(':',1)[1])
    except Exception: pass
pct=None
if LF: pct = LH/LF*100.0
# Fallback: JaCoCo XML
if pct is None:
    covered=missed=0
    for fp in glob.glob('artifacts/**/*.xml', recursive=True):
        try:
            r=ET.parse(fp).getroot()
            for c in r.findall(".//counter[@type='LINE']"):
                covered += int(c.attrib.get('covered','0') or 0)
                missed  += int(c.attrib.get('missed','0') or 0)
        except Exception: pass
    tot=covered+missed
    if tot: pct=covered/tot*100.0
if pct is None:
    print("[CI] Line coverage: not found")
    print("- Line coverage: not found")
    
    # do not fail hard if missing
    if os.environ.get("COVERAGE_REQUIRED","0")=="1":
        sys.exit(1)
    sys.exit(0)
else:
    print(f"[CI] Line coverage: {pct:.2f}%")
    print(f"- Line coverage: {pct:.2f}%")
    minv=float(os.environ.get("COVERAGE_MIN","18"))
    if pct < minv: sys.exit(1)
PY
