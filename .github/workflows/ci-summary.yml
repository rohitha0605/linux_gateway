name: CI Summary

on:
  workflow_run:
    workflows: ["CI"]          # exact name of your CI workflow
    types: [completed]
  workflow_dispatch:
    inputs:
      run_id:
        description: "CI run id to aggregate (optional)"
        required: false
  push:
    branches: [ main ]
  pull_request:

concurrency:
  group: ci-summary-${{ github.ref }}
  cancel-in-progress: true

jobs:
  aggregate:
    runs-on: ubuntu-latest
    env:
      COVERAGE_MIN: "18"
      REPO: ${{ github.repository }}
    steps:
      - name: Resolve run_id and download artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WF_NAME: "CI"        # exact workflow name
        run: |
          set -euo pipefail
          mkdir -p artifacts
          RID=""
          # 1) workflow_run payload
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            RID="${{ github.event.workflow_run.id }}"
          fi
          # 2) manual input
          if [ -z "${RID}" ] && [ -n "${{ inputs.run_id || '' }}" ]; then
            RID="${{ inputs.run_id }}"
          fi
          # 3) push/PR: find CI run for this commit SHA
          if [ -z "${RID}" ]; then
            echo "Resolving run id for '${WF_NAME}' at $GITHUB_SHA"
            RID="$(gh run list -R "$REPO" --json databaseId,headSha,workflowName -L 50 \
                  --jq ".[] | select(.headSha==\"$GITHUB_SHA\" and .workflowName==\"${WF_NAME}\") | .databaseId" \
                  | head -n1 || true)"
          fi
          if [ -z "${RID}" ]; then
            echo "::error::No run_id to aggregate for $GITHUB_SHA (workflow '${WF_NAME}' not found)."
            exit 1
          fi

          echo "Downloading artifacts from run_id=$RID"
          if ! gh run download -R "$REPO" "$RID" -D artifacts; then
            echo "::warning::No artifacts found in run $RID"
          fi

      - name: JUnit summary (fail on failures/errors)
        shell: bash
        run: |
          python3 - <<'PY' | tee -a "$GITHUB_STEP_SUMMARY"
          import os, sys, xml.etree.ElementTree as ET
          paths=[]
          for r,_,fs in os.walk('artifacts'):
              for fn in fs:
                  if fn.endswith('.xml') and ('junit' in fn or 'test-results' in r or 'surefire' in r or 'failsafe' in r):
                      paths.append(os.path.join(r,fn))
          if not paths:
              print("[CI] JUnit: 0 tests, 0 failures, 0 errors, 0 skipped"); sys.exit(0)
          T=F=E=S=0
          for p in paths:
              try:
                  root=ET.parse(p).getroot()
              except Exception:
                  continue
              suites=[root] if root.tag.endswith('testsuite') else root.findall('.//testsuite')
              for ts in suites:
                  T+=int(ts.attrib.get('tests',0) or 0)
                  F+=int(ts.attrib.get('failures',0) or 0)
                  E+=int(ts.attrib.get('errors',0) or 0)
                  S+=int(ts.attrib.get('skipped',0) or 0)
          msg=f"[CI] JUnit: {T} tests, {F} failures, {E} errors, {S} skipped"
          print(msg)
          print("### CI Summary\n\n- "+msg[5:]+"\n")
          if F>0 or E>0: sys.exit(1)
          PY

      - name: Coverage summary (ignore src/main.rs; LCOV â†’ JaCoCo XML fallback)
        shell: bash
        env:
          IGNORE_RE: '$a'
        run: |
          set -euo pipefail
          : "${GITHUB_STEP_SUMMARY:=/tmp/STEP_SUMMARY.md}"
          python3 - <<'PY'
          import glob, re, os, xml.etree.ElementTree as ET
          ignore = re.compile(os.environ.get("IGNORE_RE", r"$a"))  # default matches nothing
          # ---- LCOV with ignore per-file ----
          pct=None
          for fp in glob.glob('artifacts/**/lcov.info', recursive=True):
              LF=LH=0
              sf=None; skip=False
              try:
                  with open(fp, encoding="utf-8", errors="ignore") as fh:
                      for line in fh:
                          if line.startswith('SF:'):
                              sf=line[3:].strip()
                              skip = bool(ignore.search(sf))
                          elif line.startswith('LF:') and not skip:
                              LF += int(line.split(':',1)[1])
                          elif line.startswith('LH:') and not skip:
                              LH += int(line.split(':',1)[1])
                          elif line.startswith('end_of_record'):
                              sf=None; skip=False
              except Exception:
                  continue
              if LF:
                  pct = (LH/LF)*100.0
                  break
          # ---- Fallback: JaCoCo XML (no ignore here) ----
          if pct is None:
              covered=missed=0
              for fp in glob.glob('artifacts/**/*.xml', recursive=True):
                  try:
                      r=ET.parse(fp).getroot()
                  except Exception:
                      continue
                  for c in r.findall(".//counter[@type='LINE']"):
                      covered += int(c.attrib.get('covered','0') or 0)
                      missed  += int(c.attrib.get('missed','0') or 0)
              tot=covered+missed
              if tot:
                  pct = covered/tot*100.0
          # ---- Print & gate ----
          if pct is None:
              print("[CI] Line coverage: not found")
              print("- Line coverage: not found")
              raise SystemExit(1)
          else:
              print(f"[CI] Line coverage: {pct:.2f}%")
              print(f"- Line coverage: {pct:.2f}%")
              minv=float(os.environ.get("COVERAGE_MIN","18"))
              if pct < minv:
                  raise SystemExit(1)
          PY
